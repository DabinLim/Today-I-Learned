# 웹 성능 최적화

> 최적화란 - 알맞은 상황으로 맞춘다
> 최적화로서 얻고자 하는 효과 - 투입 노력에 비해 높은 효과


## 프론트엔드 최적화

프론트엔드의 비중이 더 큼

- 스크립트 병합, 브라우저 호출 개수를 줄인다
- 스크립트 크기를 최소화
- 스크립트를 gzip등으로 압축하여 전달
- webp 등으로 이미지 형식 최적화
- 이미지 손실, 무손실 압축
- cache-control 응답 헤더를 통해 브라우저 캐시 사용
- 도메인 수를 줄여 dns 조회 최소화
- dns 정보 미리 읽어오기
- css를 html 상단, 자바스크립트를 하단에 위치
- 페이지  미리 읽어 오기 (prefetching)
- 타사 스크립트 조정

## 백엔드 최적화

- dns 응답이 빨라지도록 서버 증설
- dns 정보 최대한 캐싱
- 웹 서버의 네트워크 출력, 대역폭 증설
- 웹서버, was의 cpu/ram 증설
- 프록시 서버 설정하여 웹 콘텐츠 캐싱
- cdn
- 데이터베이스 정규화로 디스크 i/o 최적화
- 데이터베이스 캐싱으로 응답을 빠르게 함
- 로드 밸런싱을 통해 부하 방지
- was 로직을 가볍고 빠르게 개발

## 프로토콜 최적화

### TCP 혼잡 제어

TCP 네트워크 통신량을 조절<br/>
네트워크 상태를 시시각각 파악하고 전송 속도를 조절

- TCP 혼잡 붕괴 : TCP 네트워크의 통신량이 실제 처리량보다 많아서 문제 발생
  - 패킷을 보내는 쪽에서 네트워크에서 수용할 수 있는 양을 파악하고 그만큼만 패킷을 보내는 약속을 통해 혼잡 붕괴 해결

혼잡제어 대표 기술
- 느린 시작(slow start) 
  - TCP 연결이 시작되면 전송 가능한 버퍼의 양인 혼잡 윈도우(Congetion Window)의 초깃값을 작게 설정하여 전송하고 ACK 응답을 받으면 패킷을 2배씩 늘려가며 패킷 유실이 발생하기 전까지 반복
  - 네트워크가 수용할 수 있는 혼잡 윈도우의 크기를 파악하여 그 이상 보내지 않음
- 빠른 재전송 (fast retransmit)
  - 먼저 도착해야 하는 패킷이 도착하지 않고 다음 패킷이 도착한 경우 일단 ACK 패킷을 보내는 방식
  - 혼잡제어가 필요한 상황임을 인지해 혼잡 윈도우 크기를 줄이는 작업도 실행
- 흐름 제어 (flow control)
  - 데이터를 너무 빠르거나 많이 전송하여 수신자 버퍼가 오버플로 되는 현상 방지
  - 데이터 전송 속도와 트래픽 수신 속도를 일치시키는 기술


### HTTP 최적화

### HTTP 지속 연결
TCP의 3way handshake로 인한 성능 감소를 개선하기 위해 Connection: keep-alive 속성으로 연결 유지<br/>
HTTP1.1 부터 기본 설정<br/>

메인페이지와 같은 접속량이 많은 페이지는 TCP 연결 수를 고려하여 사용여부를 결정하여야 함<br/>

복수개의 http 요청과 응답을 병렬로 동시에 처리하기 위한 파이프라이닝 기술 사용을 위해 지속 연결기능이 지원되어야 함

### HTTP 파이프라이닝
먼저 요청된 응답이 지연되더라도 병렬적으로 응답을 받을 수 있는 구조

### 웹사이트 사용중 도메인 확인
사용중 도메인의 DNS 조회시 성능이 느려질 수 있음
개발자 도구 Source에서 확인

### 도메인 운용 최적화

도메인 분할시 상위 도메인을 동일하게 해 DNS 질의를 최대한 적게 만드는 것이 좋다.<br/>
공통된 상위 도메인을 사용하는 서비스들은 네임 서버의 캐싱 정보를 재사용할 수 있어 DNS 질의 시간을 단축시킨다.<br/>

dns-prefetch
웹 문서 페이지를 여는 시점에 멀티 스레드 방식으로 미리 dns를 조회해 빠르게 ip주소를 불러오는 기술
```html
<link rel="dns-prefetch" href="google.com" /> 
```


## 브라우저 성능 확인

### Navigation Timing API
웹 성능 측정 데이터 제공, 종단간 대기 시간 정보 제공<br/>
window.performance 개체의 속성으로 사용가능

- navigation : 사용자가 어떻게 페이지를 탐색하는지 조사
- timing : 탐색과 페이지 로드 이벤트에 대한 데이터


```js

const timing = performance.timing;
//사용자가 느끼는 페이지 로딩 시간

const now = new Date().getTime();
const pageLoadTime = now - timing.navigationStart;


// API 속성 값으로 구하는 페이지 전체 로딩 시간
const pageLoadTimeByApi = timing.loadEventEnd - timing.navigationStart;

// http 요청 응답 시간
const connectTime = timing.responseEnd - timing.requestStart;

```
