# 백준 4673 문제 풀이

## 문제
- 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.

- 양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 

- 예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.

- 33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...

- n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 

- 생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97

- 10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.


## 출력
- 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.


## 예제 출력

1<br>
3<br>
5<br>
7<br>
9<br>
20<br>
31<br>
42<br>
53<br>
64<br>
 |<br>
 |       <-- a lot more numbers<br>
 |<br>
9903<br>
9914<br>
9925<br>
9927<br>
9938<br>
9949<br>
9960<br>
9971<br>
9982<br>
9993<br>

## 문제 풀이

```
n = list(range(1,10001))
dn =[]

for i in n:
    str_i = str(i)
    list_i = list(str_i)
    int_list_i = list(map(int, list_i))
    list_sum = sum(int_list_i[0:]) + i
    dn.append(list_sum)

self = list(set(n) - set(dn))
result_list = sorted(self)
for result in result_list:
    print(result)

```
<br>

> 각 자릿수의 숫자를 더하기 위해 형변환을 이용했다.<br>
우선 문제에 나오는 d(n) 함수를 만들고 문제를 제출할땐 위 코드 처럼 호출 없이 실행 되게 코딩하였고 결과는 dn이라는 변수에 새로운 리스트를 만들어 추가하였다.<br>
d(n) 함수로 만들 수 없는 숫자가 셀프넘버이기 때문에 1~10000의 숫자가 저장된 n에서 d(n) 함수로 만들어진 숫자를 뺀다.

<br>

## 새로 알게 된 개념

### set 자료형의 특징 : <br>
- 중복을 허용하지 않는다.
- 순서가 없다
- 교집합 합집합 차집합을 구할때 유용하게 사용 가능하다.
- 위 코드에서는 중복을 제거하고 차집합을 구하기 위해 사용
- [set 자료형에 대해 더 자세히](https://github.com/DabinLim/Today-I-Learned/blob/master/Python/map().md)