# 재귀 함수 

## 재귀 함수란?
- 재귀(Recursion)는 어떠한 것을 정의 할 때 자기 자신을 참조하는 것은 뜻한다.

- 재귀 함수를 호출할때는 반드시 빠져나가는 지점 (탈출 조건)을 명확히 해주어야 한다.<br>
그렇지 않으면 무한 루프에 빠져 에러가 난다.(Stack over flow)

## 재귀 함수의 대표적인 예
<br><br>

### 1. 팩토리얼

팩토리얼은 1부터 n까지의 정수를 모두 곱한 것을 뜻한다.<br><br>
즉, Factorial(n) = n * Factorial(n - 1)<br>
Factorial(n - 1) = (n - 1) * Factorial(n - 2)<br>...<br>
의 구조이다.

```
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)


print(factorial(60))
```
<br>
factorial 함수 안에서 n-1의 인자를 줘서 반복적으로 호출한다.
n의 값이 1이 된다면 반환하여 탈출한다.
<br><br>

### 2. 하노이의 탑 규칙 및 코드 작성

<br><br>
하노이 탑은 일종의 퍼즐이다<br>
규칙은 다음과 같다.<br>
- 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 
- 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
- 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.
- 목표는 첫 번째 장대의 원판을 모두 세 번째 장대로 옮기는 것이다.
- 이 작업을 수행하는데 필요한 이동 순서를 구한다.
- 단, 이동 횟수는 최소가 되어야 한다.


<img src="https://github.com/DabinLim/Today-I-Learned/blob/master/images/hanoi.png">

<br>
<br>
아래는 하노이 탑의 답안이다.<br>
아래의 코드를 분석하며 재귀함수의 개념을 정리한다.<br><br>

```
def hanoi (n, from, to, other):
    if n == 1:
        print(from, to)
        return
    hanoi(n -1 , from, other, to)          # 1번 재귀
    print(from, to)
    hanoi(n-1, other, to, from)            # 2번 재귀

hanoi(num,1,3,2)                   n: 원판의 갯수
print(len(move_list))              from: 시작 장대
for i in move_list:                to: 목표 장대
    print(i[0], i[1])              other: 보조 장대
    
```
위의 문제를 풀기 위해 우선 첫 번째 장대에서 세 번째 장대로 모두 옮기기 위한 조건들을 찾아본다


- 모든 원판을 옮기기 위해선 가장 큰 원판을 목표 장대의 가장 아래로 옮겨야 한다.
- 가장 큰 원판을 목표 장대로 옮기기 위해선 나머지 원판들이 목표 장대가 아닌 장대에 위치하여야 한다.

위 조건을 코드로 표시하면 <br>
```
hanoi(n -1 , from, other, to)
```
가 된다. 

가장 큰 원판 외의 모든 원판이 보조 장대로 옮겨졌으면 가장 큰 원판을 목표 장대로 옮겨야 한다.<br>
이를 코드로 표현하면 
```
if n == 1:
        print(from, to)
        return
```
가장 큰 원판이 목표 장대에 있고 나머지 원판들이 보조 장대에 있다면 <br>
이제 가장 큰 원판은 신경 쓸 필요가 없어진다.
<br>
그러므로 나머지 원판들을 3번 장대로 옮기기 위해 from, to, other 을 다시 지정한다.
이를 코드로 표현하면 

```
hanoi(n-1, other, to, from) 
```


### 3. 하노이의 탑 실행 과정

솔직히 코드 작성과정만 보고 이해하기는 힘들다. (힘든게 아니라 못한다고 생각함)
<br>
코드의 실행 과정도 정리하였다.

```
def hanoi (n, from, to, other):
    if n == 1:                            #
        print(from, to)
        return
    hanoi(n -1 , from, other, to)          # 1번 재귀
    print(from, to)
    hanoi(n-1, other, to, from)            # 2번 재귀

num = 3
hanoi(num,1,3,2)                   n: 원판의 갯수
print(len(move_list))              from: 시작 장대
for i in move_list:                to: 목표 장대
    print(i[0], i[1])              other: 보조 장대
```

>우선 작성된 hanoi 함수가 실행된다. 이를 0번 함수라 하겠다.<br>
실행된 함수에서 원판의 갯수 n은 3이다. <br><br>
첫번쨰 if문에서 n은 1이 아니므로 실행하지 않고 1번재귀를 만나 함수를 새로 호출하고 0번 함수는 일시정지 된다.<br>새로 호출 된 이 함수를 1번 함수라 하겠다.<br><br>
1번 함수의 n은 n-1를 받아 2가 되었지만 여전히 1이 아니므로 if문을 지나쳐 다시 1번 재귀를 만나 함수를 새로 호출한다.<br>
마찬가지로 1번함수는 일시정지 되고 새로 호출된 함수는 2번 함수라 하겠다.<br><br>
2번 함수의 n은 n-1을 받아 1이 되어 if문 안의 print를 실행하고 return 한다.<br>
1 3<br>
1번 장대의 원판을 3번으로 옮긴다.
<br><br>
2번 함수가 return 되어 1번함수로 돌아오고 1번함수는 1번재귀를 실행한 후 일시정지 되어 있었으므로 1번재귀 다음의 print부터 다시 실행하게 된다.<br>
1 2<br>
1번 장대의 원판을 2번으로 옮긴다.
<br><br>
print문을 실행한 후 아래의 2번 재귀를 만나 새로운 함수를 호출한다.<br>
이 함수는 3번함수라고 하겠다.<br><br>
3번함수는 1번 함수 안에서 실행 되었으므로 1번 함수의 n값 2를 인자로 받아 n값이 1이 된다.<br>
그러므로 if문을 실행하고 return 한다.<br>
3 2<br>
3번 장대의 원판을 2번으로 옮긴다.<br><br>
3번함수가 return되고 1번함수로 돌아왔지만 1번함수로 마지막 코드를 실행하고 끝이 났다.<br>
1번 함수가 끝이 났으므로 일시정지 되었던 0번 함수로 돌아와 실행하지 못한 1번 재귀 다음 코드부터 실행한다.<br>
1 3<br>
1번 장대의 원판을 3번으로 옮긴다.<br><br>
과정을 반복한다.


위에서처럼 함수 안에서 함수를 호출하는 것을 재귀호출이라 한다.<br>
규칙을 찾아 반복할 수 있게 코드를 짰기 때문에 num의 값(원판갯수)이 몇이든 반복을 통해 이동 과정을 출력할 수 있다.

## 재귀함수의 장점

우선 장점에 앞서 단점으로는 재귀함수는 호출 할때마다 중간 값을 저장하기 위한 메모리가 필요하다.<br>
그러므로 재귀함수는 반복문보다 많은 메모리를 소모해 탈출조건을 명시하지 않을 경우,<br>
Stack over flow 에러를 보게 된다.<br>
또한 메모리의 사용량이 많아 성능이 좋지 않으며 느리다.<br>
그럼에도 재귀 함수를 사용하는 이유는 아래와 같다
- **알고리즘 자체가 재귀적 표현이 자연스러운 경우**
    - `(ex_ 피보나치 수열, 팩토리얼, 하노이탑)`

- **변수 사용을 줄여줄 수 있다.**
  - `변수 사용을 줄여 프로그램에 오류가 생길 가능성을 줄이고, 프로그램이 정상적으로 돌아가는지에 대한 증명이 쉬워진다.`
- **가독성이 향상된다.**
    - `반복문에 비해 코드량이 줄어들고 사용하는 변수가 줄어들어 가독성이 향상된다.`

<br><br>

## 꼬리 재귀

함수를 호출하면 함수가 호출된 위치를 가리키는 주소 값이 저장되어야 한다.<br>
함수가 재귀적으로 호출될 경우 함수 안에서 함수가 계속해서 호출되고 차례로 리턴된다.<br>
그래서 호출 횟수가 많아지면 돌아갈 곳의 주소 값을 저장하고 있는 스택이 넘치거나 프로그램의 실행 속도가 느려지는 단점이 있다.<br>
위의 문제는 함수가 호출된 위치를 기억하기 때문에 발생한다.<br>
이를 위해서 꼬리 재귀가 사용된다.<br><br>
꼬리 재귀란 재귀 함수를 원래 함수의 꼬리 부분에서 호출하는 경우를 말하는데 컴파일러는 꼬리 재귀로 작성된 코드를 인식해서 반복문으로 바꿔준다.<br>
코드 상에서 해결되는 건 아니고 컴파일러가 꼬리 재귀를 인식하고 코드를 최적화 하면서 일반 재귀가 가지는 단점을 없애준다.<br><br>
꼬리 재귀는 함수가 호출된 위치로 돌아갔을 때 실행할 작업을 없애 함수 호출 위치를 저장하지 않도록하여 스택이 넘치는 경우를 방지한다.<br><br>
꼬리 재귀 구현 부분이 일반 재귀랑 같게 실행이 될 수있는데 , 컴파일 옵션에서 코드 최적화가 되도록 설정해 주어야 한다.<br><br>
꼬리 재귀는 결국 반복문 실행이기 때문에 일반 재귀 함수에서 발생하는 스택 오버 플로우나 성능저하가 발생하지 않는다.<br>
재귀 모습을 한 반복문이기에 가독성 또한 우수하다.