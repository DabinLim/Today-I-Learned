# 면접 질문 준비

### 1. InfinityScroll 컴포넌트에 대한 설명

useCallBack 을 사용한 이유 : 함수형 컴포넌트에서 state가 업데이트 되면 리렌더링이 되면서 throttle이 초기화된다.<br>
useCallBack을 통해 메모이제이션해서 사용하여 is_loading이 변할때만 초기화 시킨다.(is_loading이 고정되있으므로 dependency에 is_loading 추가)<br>
전체 스크롤 높이에서 현재 스크롤top의 높이와 보이는 부분의 높이를 뺀 값이 100px미만일때 콜백함수 실행

### 2. lodash를 사용한 이유, lodash에 대한 설명

lodash를 사용하면 자비스크립트에서 배열, 숫자, 객체, 문자열 등의 데이터 관리를 쉽게 만들어준다.<br>
배열, 객체 및 문자열 반복값 조작, 복합 함수를 만드는데 적합하다.<br>
실제로 사용해본 메소드는 throttle과 debounce이다.<br>

### 3. throttle과 debounce의 차이

throttle과 debounce를 사용하여 이벤트 발생 빈도수를 조절해준다.<br>
throttle의 경우 아무리 많은 이벤트가 발생하여도 설정한 시간마다 한번씩만 이벤트가 발생하며(설정한 시간안에 발생한 이벤트 중 가장 마지막 이벤트에 대한 콜백이 실행된다.)
debounce의 경우 유저가 행동을 멈춘 후에 설정한 시간이 지나야만 이벤트가 발생한다.<br> 
throttle은 무한스크롤, resize이벤트 등에 사용되고 debounce의 경우 인풋값을 입력할때 입력값 하나하나마다 이벤트가 발생하지 않도록 빈도수를 조절하기 위해 사용된다.<br>
이벤트 발생 자체를 막는 것이 아니라 콜백을 제어한다.

### 4. javascript prototype

자바스크립트에서의 함수는 객체이다.<br>
그러므로 프로퍼티를 가질 수 있다.<br>
함수가 파싱될때 prototype이라는 프로퍼티를 갖는 생성자객체와 constructor 프로퍼티를 갖는 prototype 객체가 생성된다.(상호참조)<br>

\_\_proto__ 를 통해 생성된 객체가 원본 객체에 접근할 수 있다.<br>
해당 객체에 메소드가 존재하지 않으면 해당 객체의 __proto__를 확인 한다.(부모의 prototype)<br>
최상위 __proto__까지 반복<br>

모든 함수의 \_\_proto__는 window.Object.prototype이다.<br>

https://www.youtube.com/watch?v=G8KNTDVEvhE

### 5. javascript this

- 일반 함수를 호출할때 this는 window를 가르킨다.

- 함수가 생성자인 경우 새로운 객체를 가르킨다.

- strict 모드에서는 undefined

- eventlistener의 콜백함수에서의 this는 이벤트리스너에 바인딩된 요소를 가리킨다.<br>
콜백함수를 화살표함수로 정의하는 경우의 this는 상위 컨택스트(전역객체)인 window를 가리킨다.<br>
콜백함수의 내부함수에서 this는 다시 window를 가리킨다. 콜백의 내부함수에서는 arrow function을 사용하거나 this를 that이라는 변수에 넣어 사용할 수 있다.

- bind()를 통해 this를 고정할 수 있다.

- call 과 apply는 bind와 같지만 bind는 this를 연결만 하고 call과 apply는 실행까지 한다.

- call 과 apply의 차이점은 call 은 인자를 하나하나 넘기는 반면 apply는 인자를 하나로 묶어 배열로 만들어서 넘긴다.

### 6. OOP에 대한 설명

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법<br><br>

코드 재사용이 용이하다, 남이 만든 클래스를 이용할 수 있고 상속을 통해 확장이 가능하다.<br>
유지보수가 용이하다.<br>
대형프로젝트에서 적합 클래스 단위로 모듈화 시켜서 개발할 수 있다.<br><br>

처리속도가 상대적으로 느리다.<br>
객체가 많으면 용량이 커질 수 있다.<br>
설계 시 많은 시간과 노력이 필요하다.



- class : 추상화를 거쳐 속성과 행위를 정의 한 것 , 데이터 없음 (붕어빵 틀)<br>

- 인스턴스(객체) : class에 실제 데이터를 넣어 새로운 인스턴스를 생성하면 나오는 것 (붕어빵)<br>

- 추상화 : 중요한 정보만 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것(클래스정의)

- 캡슐화 : 기능과 특성의 모음을 클래스라는 캡슐에 분류해서 넣는 것, 재수정 없이 재활용을 목표로 한다.

- 상속 : 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게 하고 기능의 일부분을 변경해야 할 경우 자식 클래스에서 해당 기능만 다시 수정하여 사용

- 다형성 : 하나의 변수명, 함수명이 상황에 따라 다른의 의미로 해석될 수 있는 것
    - 오버라이딩 : 부모클래스의 메서드와 같은 이름, 매겨변


### 7. html이 그려지는 과정

1. DNS 서버를 통해 IP주소를 받아온다
2. IP주소를 이용해서 서버에 요청을 보낸다.
3. 서버는 요청에 대한 응답을 보내준다 (html,css,js)
4. 브라우저가 응답 결과를 렌더링한다.
    - DOM트리 구성 : 마크업 언어로 만들어진 문자열을 메모리에서 다루기 위해 파싱하고 결과를 로딩, 메모리에 만들어진 객체는 document라고 하고 완성된 구조를 DOM 트리라고 한다.
    - 렌더트리 구성 : html과 css를 고려하여 현재 화면에 나와야 하는 요소들만 추려서 만들어진 부분을 렌더트리라 한다.
    - 레아이웃 처리와 페인팅 : 화면에 보여질 요소들을 파악한 렌더트리는 css를 이용해 레이아웃 구성
    - 유저들의 viewport 크기에 따라서 페이지가 그려진다.

### 8. Promise (비동기 처리)

비동기 처리 시에는 실행의 종료를 기다리지 않고 바로 다음 코드를 실행하기 때문에 원하는 처리를 위해 콜백함수를 사용한다.<br>
콜백함수 내에서 또다른 비동기 처리를 위해서 콜백함수를 다시 사용하고 이렇게 꼬리를 물다보면 콜백 헬이 탄생하게 된다.<br>

이를 해결하기 위해서 ES6에서 도입한 또다른 비동기 처리 패턴이 Promise이다.<br>

비동기 연산이 종료된 이후 결과를 알기 위해 사용하는 객체<br>
프라미스를 쓰면 비동기 메소드를 마치 동기 메소드처럼 값을 반환할 수 있다.<br>

### 9. javascript 이벤트 위임

하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식<br>
사용하는 메모리의 양이 감소한다.<br>

이벤트 버블링 : 이벤트가 하위 요소에서 상위요소까지 전파<br>

이벤트 캡쳐링 : 이벤트가 상위 요소에서 하위요소까지 전파<br>

currentTarget = 이벤트의 주인<br>
target = 이벤트가 누구때문에 실행?

### 10. 쿠키에 토큰을 저장한 이유, 장단점, 쿠키에 대한 설명

WebStroage에 토큰을 저장하는 경우 js코드로 접근이 가능해 XSS 공격에 취약하다.<br>
httponly 옵션과 secure 옵션을 활용, csrf 공격에 대비를 하면 webstroage보다는 안전한 쿠키에 저장<br>
유효기간 설정 가능<br>
default로 header에 쿠키 값을 담을 수 있어 유지보수에 유리하다.<br>
여전히 세션 저장보다는 보안에 취약


- XSS : Cross Site Scripting 으로 사용자의 정보 탈취가 목적

- CSRF : Cross Site Request Forgery 으로 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 하는 공격 기법



- 쿠키에 대한 설명 : 사용자 정보를 저장하기 위해 디바이스에 저장하는 파일, 장바구니, 방문 기록 등 광고 타겟팅을 위해서도 사용된다.

- 퍼스트파티 쿠키 : 현재 방문하는 도메인에 설정된 쿠키, 장바구니, 토큰 저장

- 서드파티 쿠키 : 방문한 도메인 외에 외부업체가 심는 쿠키, 사이트를 넘나들며 사용자 행동 추적, 타겟팅 광고에 사용된다.

### 11. jwt 토큰을 사용한 이유, 장단점

세션 사용에서 나오는 서버 부하, DB에 저장할 경우 DB부하를 고려하여 토큰 사용

장점<br>
1. 훌륭한 확장성 : 스케일 아웃(서버확장)을 하여도 토큰을 인증하는 방식만 알고 있다면 사용자 인증에 문제가 없다<br>
jwt를 사용하지 않고 세션 전용 서버를 만들어 DB에 저장하는 방법도 있지만 인증이 필요한 모든 api 요창에 대해 서버에 조회를 해야 하기 때문에 DB부하를 만들 수 있다.

2. 보안성 : jws 서명 인증으로 무결성 입증 signature 영역은 서버 비밀키를 통해 hmac 알고리즘으로 암호화

3. 클라이언트가 서버로 요창할 때 쿠키를 전달하지 않기 때문에 쿠키를 사용함으로써 발생하는 취약점이 사라진다.

4. CORS 문제를 해결한다. 쿠키는 발행한 서버에서만 유효하지만 jwt는 어떤 도메인에서도 토큰만 유효하다면 처리가 가능하다.

5. 브라우저의 쿠키 처리 방법과 모바일 기기의 쿠키 처리 방법이 다르다, jwt를 이용하면 다양한 디바이스 지원에 유리하다.

단점 <br>
1. 모든 요청에 대해 토큰이 전송되므로 토큰에 담기는 정보가 증가할 수록 네트워크 부하가 증가된다.
2. 토큰 자체에 정보를 담고 있어 만료시간 전에 탈취당하면 보안에 취약하다.

3. Payload는 암호화 된 것이 아니라 base64로 인코딩 된 것이다. 중간에 payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로 payload에 중요한 정보를 넣지 말아야 한다.

4. jwt는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 토큰을 임의로 삭제하는 것이 불가능하므로 만료 시간을 꼭 넣어 주어야 하며, 만료시간을 짧게 하고 refresh-token이라는 새로운 토큰을 발급한다.

### 12. 리액트 훅에 대한 설명 (useSelector, useDispatch, useRef, useState, useCallBack)

훅이 도입 된 목적 <br>

1. 라이프사이클 메서드 기반이 아닌 로직 기반으로 나누어 컴포넌트를 함수 단위로 잘게 조갤 수 있다.
2. 함수형 컴포넌트에서도 상태관리를 사용하기 위함
3. 불필요한 this의 사용을 피할 수 있다.

useState 

- 함수형 컴포넌트에서 상태를 관리할 때 사용
- 하나의 state에 여러 프로퍼티를 추가하여 상태 관리 가능(객체로 사용 가능)

useEffect

- 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정할 수 있는 훅이다. 라이프사이클 합친형태
- 사이드 에픽트 수행 가능 (데이터 가져오기, 구독 설정 등)
- 특정 값이 업데이트 될때만 useEffect를 실행하고 싶을 경우 두번쨰 파라미터 배열에 해당 값 추가
- 불필요한 렌더링 방지를 위해 dependency에 참조하는 모든 외부변수를 추가 할 것을 권장
- 구독 설정을 한 경우 메모리 누수를 방지하기 위해 clean-up을 꼭 해주어야 한다.

useRef

- 함수형 컴포넌트에서 일반적으로 DOM에 접근하는데 익숙한 ref를 사용할 수 있게 한다.
- .current 프로퍼티에 변경 가능한 값을 담고 있는 상자와 같다.

useMemo

- 함수형 컴포넌트 내부에서 발생하는 연산 최적화 가능
- 의존성이 변경되었을때만 메모이제이션 된 값을 다시 계산한다.
- 가능하면 useMemo를 사용하지 않고도 동작할 수 있도록 코드를 작성하는 것이 더 바람직하다.
- 숫자, 문자열, 객체 같은 일반 값 재사용

useCallback 

- 메모이제이션 된 콜백을 반환한다. 주로 렌더링 성능 최적화를 위해 사용
- 이 훅을 통해 이벤트 핸들러 함수를 필요할때만 생성할 수 있다.
- 인라인 콜백과 의존성 값의 배열을 전달하면 콜백의 메모이제이션 된 버전을 반환한다. 이는 의존성이 변경되었을때만 변경이 된다.
- 함수 재사용

useSelector

- 리덕스의 상태값을 조회하기 위한 훗으로 간결하게 조회가 가능

useDispatch

- redux의 action에 연결하기 위한 훅으로 상태 변경을 위해 사용

### 13. Axios를 사용한 이유

**http 요청 및 응답을 json 형태로 자동 변경해줘 편리하다.**<br>
**브라우저 호환성이 좋다.**<br>
400~500 state의 error 발생시 reject로 response를 전달해 catch로 받을 수 있다.<br>
fetch의 경우 네트워크 장애나 요청이 완료되지 않은 경우에만 reject로 response를 전달하기 때문에, resolve로 받아 따로 예외처리가 필요.

### 14. redux toolkit을 사용한 이유, 설명

 기존 리덕스를 사용할 때 액션, 액션함수, 리듀서를 다 따로 작성해야하기 때문에 코드양이 너무 길어져서 불편함을 겪었다. 패키지(thunk, immer)를 별도로 받아야 된다는 불편함도 있었다.<br>
 그래서 redux에서 권장하는 redux toolkit 패키지를 사용하게 되었다.<br>
 redux-toolkit createSlice를 사용하면 액션 타입 액션 함수 리듀서 기능이 합쳐져 있어서 코드의 양을 많이 줄일 수 있었다.<br>
 또한 redux-toolkit의 default middleware에 thunk와 immer가 포함되어있어 별도의 패키지를 받아올 필요가 없었다.

### 15. 리액트, vue, angular 차이점

1. 리액트를 사용하는 경우

- 빠른 일정 안에 엔터프라이즈 수준의 가벼우면서도 현대적인 애플리케이션을 개발해야 할 때
- 웹사이트 개발 솔루션을 안전하게 보호할 수 있는 유연한 프레임워크가 필요할 때
- 크로스 플랫폼 애플리케이션이나 싱글 페이지 애플리케이션을 개발할 때
- 기존의 앱에서 기능성을 확장할 때
- 강력한 커뮤니티 지원과 솔루션이 필요할 때
- 어떠한 라이브러리라도 리액트에 맞춰 넣을 수 있다는 장점이 있다.

2. 앵귤러를 선택해야 하는 경우

- 기능이 풍부하고 규모가 큰 애플리케이션을 개발할 때
- 믿을 수 있고 확장 가능한 프레임워크가 필요할 때
- 채팅 앱이나 메시징 앱과 같은 실시간 애플리케이션을 개발할 때
- 장기프로젝트이며, 투자규모도 상당한 네이티브 앱이나 하이브리드 앱, 또는 웹 앱을 개발할 때
- 가장 복잡하고 큰 러닝커브

3. 뷰를 선택해야 하는 경우

- 가장 적은 러닝커브를 가지고 있다.
- 시장 진입 단계에서 필요한 프레임워크를 선택할 때
- 작고 가벼운 애플리케이션을 개발할 때
- 기존의 프로젝트에서 현대적이지만 제한된 리소스를 가진 프레임워크로 마이그레이션을 해야할 때
- 기업이 아니라 사용자 커뮤니티의 지원을 받는 프레임워크를 원할 때

### 16. 리액트의 특징, 가상돔에 대한 설명

SPA, CSR : 서버로부터 데이터를 받아 클라이언트에서 렌더링한다.<br>
CSR 과 SSR을 같이 사용하여 SEO해결 가능<br>
여러개의 독립적인 컴포넌트로 분리하여 관리 할 수 있어 재사용성을 높인다.<br>
<br>
가상돔으로 인한 빠른 속도 : 데이터가 변경될때마다 DOM 전체에 직접 접근하여 변화를 주게 되면 성능이 느려질 수 밖에 없음<br>
리액트는 데이터가 변경되면 가상 DOM을 변경하고 실제 DOM과 비교하여 변경된 부분만 실제 DOM에 반영한다.<br>
자유도가 높고 개발을 처음 배우는 입장에서 가장 선호도가 높기 떄문에 선택했다.

### 17. webpack 과 babel

- 웹팩: 자바스크립트 어플리케이션을 위한 정적 모듈 번들러<br> 의존성이 있는 모듈들을 하나의 파일로 통합시켜준다.<br>한 웹페이지에서 사용하는 여러개의 자바스크립트를 동시에 가져와서 생기는 네트워크 병목현상 방지<br>모듈 단위로 개발할 수 있어 유지보수성을 높일 수 있음.


- 바벨 : 최신 자바스크립트를 사용할 수 있게 하는 트랜스파일러<br>
	다양한 웹 브라우저, node.js 등 각기 다른 환경에서 모두 정상적으로 동작할 수 있도록 한다.

### 18. javascript callstack

### 19. setTimeout 에 대한 설명

페이지가 전환되지 않는 경우, 특히 spa의 경우 사용되지 않은 setTimeout() 코드가 메모리에 계속 남아 있을 수 있어 성능저하의 원인이 된다. setTimeout() 이벤트를 제거하는 clearTimeout()을 사용하여야 한다.<br>
setTimeout()이 호출되면 호출스택에 쌓이고 콜백함수는 백그라운드로 이동해 설정된 시간동안 기다린다.<br>
설정된 시간 후에 태스크 큐로 이동하고 호출스택이 **비어있다면** 호출스택으로 이동해 실행된다.


### 20. 웹디자인 길이 단위 px, rem, em, vw, vh, vmax, vmin에 대한 설명

### 21. 콜백 함수란?

나중에 호출되는 함수, 개발자가 등록한 함수가 특정 이벤트가 발생하거나 시점에 도달 했을때 시스템에서 호출하는 함수

### 22. es5 와 es6의 차이

arrow function 추가, const let, class, 템플릿 리터럴, require을 통해 라이브러리 임포트 가능
es5는 2009년, es6는 2015년에 등장하였으며 이후 매년 새로운 버전 등장

### 23. setter 와 getter

사용자의 실수로 인해 말이 안되는 값을 가지지 않도록 setter와 getter로 제어

```
get age(){
    return this._age;
}

// age의 값이 0보다 적을 경우 0으로 세팅

set age(value){
    this._age = value < 0 ? 0 : value;
}
```

### 24. hoisting 이란?
변수를 선언하고 초기화했을 때 **선언부분이** 가장 위로 올라간다.
호이스팅 이후 선언된 순서대로 실행된다.<br>
함수 선언식인 경우 (ex_ function hoisting(){};) 식 자체가 통째로 끌어올려진다.<br>
때문에 함수 선언식은 선언 전에 호출하여도 정상 작동, 변수는 선언 전에 사용하면 에러가 아니라 undefined를 반환한다.<br>
함수 표현식의 경우는 선언만 끌어올려져 선언(대입)전에 호출 시 에러

### 26. Arrow function 에 대한 설명

- es6 문법

- function 표현에 비해 구문이 짧고, 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않는다.

- 항상 익명이다.

- 메소드 함수가 아닌 곳에 적합하다, 생성자로 사용할 수 없다.

### 27. javascript 실행 컨텍스트

처음 코드가 실행되는 순간 모든 것을 포함하는 전역 컨텍스트가 생긴다.<br>
함수를 호출할 때마다 함수 컨텍스트가 하나씩 더 생긴다.<br>
컨텍스트 생성 시 컨텍스트 안에 변수객체(argyments, variable), scope chain, this가 생성된다.<br>
함수 실행이 마무리되면 해당 컨텍스트는 사라진다.<br>
페이지가 종료되면 전역컨텍스트가 사라진다.

- 전역 컨텍스트 : 전역컨텍스트의 arguments는 없다<br> variable은 해당스코프의 변수들이다 (전역변수), scope chain은 전역 변수객체이다. this는 따로 설정되어 있지 않으면 window이다.<br>
함수 내부에서 함수가 호출되더라도 호출된 함수의 선언이 더 먼저라면 lexical scope에 의해 먼저 설정된 scope chain을 따른다.

- 함수 컨텍스트 : scope chain은 함수 내부 변수객체, 상위 객체, this는 new 또는 bind를 따로 하지 않으면 window이다.

- lexical scoping(정적스코프) : 함수는 선언하는 순간 함수 내부의 변수는 상위부터 자신의 스코프로부터 가장 가까운 곳의 변수를 계속 참조한다.

- scope chain : 내부함수에서 변수를 찾을때 자기 자신의 스코프에서 먼저 찾고 없으면 상위 스코프에서 변수를 찾는 관계를 나타낸다.

위의 이유로 전역변수를 사용하면 변수가 섞일 가능성이 있으므로 전역변수를 지양한다.<br>
해결방법으로는 한번 함수 안에 넣어 지역변수로 만들거나 네임스페이스를 만들어 객체 안의 속성으로 만든다. (ex_ facebook FB, naver jindo, jquery $)<br>

### 28. 클로저

외부함수의 호출이 종료되더라도 외부함수의 지역변수 및 변수 스코프를 유지할 수 있는 구조를 클로저라고 합니다.<br>
비공개 변수를 가질 수 있는 환경에 있는 함수가 클로저<br>
생성될 당시의 스코프체인을 기억하여 스코프체인을 통해 접근할 수 있는 변수나 함수가 스코프가 해제되어야 할 시점에도 사라지지 않는다.<br>
이러한 스코프를 사용하여 캡슐화와 은닉화를 구혀하는데 사용될 수 있다.<br>
사용자 통제를 위한 기본적인 방법이다.<br>
단점으로는 성능문제와 메모리 문제가 발생할 수 있다. 비공개 변수는 자바스크립트에서 언제 메모리 관리를 해야할지 모르기 때문에 자칫 메모리 낭비로 이어질 수 있다.<br> 
또한 scope chain을 거슬러 올라가는 행동을 하기 때문이 느려질 수 있다.

### 29. infinity scroll ux적으로 왜 사용하는지?

페이지네이션은 사용자가 특정한 콘텐츠를 찾고 있는 웹사이트에 가장 적합하다.<br>
무한 스크롤은 사용자가 무언가 흥미로운 콘텐츠를 보기 위해 목적 없이 검색하는 상황에서 더 적절합니다.<br>
또한, 모바일 기기에서 매우 편하게 사용가능하다.

### 30. 리액트 라이프 사이클

컴포넌트가 실행되거나 업데이트되거나 제거될 때, 특정 이벤트가 발생한다, 이를 생명주기라 한다.<br><br>

Class 컴포넌트에서의 라이프 사이클

1. 컴포넌트 실행 

컴포넌트가 처음 실행될때 Mount라 하고, context,defaultProps,state을 저장한다.
그 후 componentWillMount(deprecated) 메소드를 호출한다.<br>
그 후 render로 컴포넌트를 DOM에 부착한 후 componentDidMount가 호출된다.<br>
componentWillMount 중에는 아직 Mount중이기 때문에 props나 state를 변경해서는 안된다.<br>
DOM에도 접근할수 없다.<br>

2. props 업데이트

props가 업데이트 될때의 과정이다.<br>
shouldComponentUpdate -> render -> componentDidUpdate <br>
이 메소드들은 첫번째 인자로 바뀔 props에 대한 정보를 가지고 있다.
두번째 인자로 바뀔 state에 대한 정보를 가지고 있다.<br>
shouldcomponentUpdate에서 아직 render하기 전이기 때문에 return false를 하면 render를 취소할 수 있다.
여기서 성능 최적화를 한다.<br>
componentDidUpdate는 두번째 인자로 바뀌기 전 state에 대한 정보를 가지고 있다.

4. 컴포넌트 제거

컴포넌트가 제거되는 것을 Unmount라 한다.<br>
컴포넌트가 제거될때 componentWillUnmount 메소드가 호출되며, 이때 이벤트 구독을 해제하는 등의 정리활동을 한다.<br><br>

함수형 컴포넌트에서의 라이프 사이클<br>
함수형 컴포넌트에서는 컴포넌트 중심이 아닌 특정 데이터에 대해서 라이프사이클이 진행된다.<br>
데이터는 여러 개일 수 있으므로 useEffect에 경우 데이터의 개수에 따라 여러 번 사용된다.<br><br>

dependency에 배열을 넣어 특정 데이터가 업데이트 되었을때, 재실행 되게 할 수 있으며 빈 배열을 넣어 처음 한번만 실행되고 다시 실행되지 않게 할 수 있다.<br>
return의 함수를 작성하여 WillUnmount의 기능을 수행할 수 있다.<br><br>

useRef로 생성한 데이터는 리렌더링 여부와 상관없이 같은 값이 유지돤다. 또한 그 값을 바꾸더라도 화면이 리렌더링 되지 않는다.<br>
useRef를 활용하여 useEffect에서 componentDidUpdate 효과를 낼 수 있다.(componentDidMount를 무시하는 방법)

### 31. 리액트의 JSX    

리액트에서 쓰이는 js를 확장한 문법이다. (Javascript XML)

React에서 JSX 사용이 필수는 아니지만 JavaScript 코드 안에서 UI 관련 작업을 할 떄 시각적으로 더 도움이 되며 React에서도 더욱 도움이 되는 에러 및 경고 메세지를 표시할 수 있게 해준다.

### 32. RestFul API 란?

### 33. SASS 

css 전처리기이다.<br>
선택자의 중첩이나 import, 조건문 등을 사용할 수 있어 기존 css에 비해 편리하다.<br>
웹에서는 css만 읽을 수 있기 때문에 웹팩을 통해 번들링할때 sass-loader를 통해 css로 변환한다.
<br><br>

- css-loader : webpack에서 .css파일을 읽기 위해 사용
- style-loader : style태그를 삽입하여 DOM을 추가
- sass-loader : .sass 또는 .scss파일을 .css파일로 변환하기 위해 사용

### 34. CDN

### 35. 리눅스 환경

### 36. React.Fragment 란?

컴포넌트가 여러 element를 return할때 jsx문법상 하나의 태그에 묶어서 return해야 한다.<br>
이때 React.Fragment를 사용하면 DOM에 별도의 노드를 추가하지 않고 사용 가능하다.

### 37. (es5) map과 forEach의 차이, filter, reduce 특징

forEach는 배열 요소마다 한번씩 주어진 함수를 실행<br>
map은 배열 내의 모든 요소에 대해 콜백을 호출하고 그 결과를 새로운 배열로 반환<br>
(배열요소값, 인덱스, 현재배열)<br>
filter 메소드는 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환한다<br>


### 38. http와 https 차이

https는 http에 보안이 추가된것<br>
ssl(보안소켓계층)을 사용하여 서버와 브라우저 사이에 암호화된 연결을 만든다.<br>
tls(전송계층보안)을 통해서도 보안유지, 데이터 무결성

### 39. 프로세스와 스레드

프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위
스레드 : 프로세스 내의 실행의 단위

### 40. socket.io 질문

양방향 통신을 위해 사용한다<br>
로그인 했을때 joinAlarm을 통해 소켓 연결<br>
알림 목록과 체크됐는지 여부를 데이터로 보내줌<br>
좋아요, 댓글, 태그, 팔로우, 댓글 좋아요에 관한 api요청시<br>
서버에서 해당 데이터를 emit하고 클라이언트는 app.js에서 on으로 데이터를 받아 리덕스 스테이트에서 관리(new_list)<br>
eventType에 따라 다른 문구를 띄워준다.<br>
